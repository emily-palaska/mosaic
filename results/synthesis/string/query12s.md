# String Code Synthesis
Query `Compare PCR and PLS regression results.`
## Script Variables
- X_test:<br>
>X_test is a matrix of 2 columns and 100 rows. It contains the values of the
- y_test:<br>
>The variable y_test is a vector of test data that is used to evaluate the performance of the model
- pcr:<br>
>pcr is a Pipeline object that is used to perform a PCA analysis on the input data. It
- print:<br>
>The print function is used to display the output of the script to the console. It takes a single
- pls:<br>
>pls is a variable that is used to store the PLS regression model. It is used to predict
- np:<br>
>np is a python library that provides a large number of mathematical functions and data structures. It is a
- n:<br>
>n is an integer value that represents the number of samples in the dataset.
- X:<br>
>X is a matrix containing the input data for the PLS regression model.
- PLSRegression:<br>
>PLSRegression is a regression model that uses principal component analysis to reduce the dimensionality of the data
- p:<br>
>It is a random number generated by the numpy library. It is used to create a matrix X which
- y:<br>
>The variable y is a 1000x1 numpy array which represents the dependent variable in the regression
- pls1:<br>
>pls1 is a PLSRegression object that is used to perform partial least squares regression on the given
## Synthesis Blocks
### notebooks/dataset2/cross_decomposition/plot_compare_cross_decomposition.ipynb
CONTEXT:  PLS regression, with multivariate response, a.k.a. PLS2   COMMENT: compare pls2.coef_ with B
```python
n = 1000
p = 10
X = np.random.normal(size=n * p).reshape((n, p))
y = X[:, 0] + 2 * X[:, 1] + np.random.normal(size=n * 1) + 5
pls1 = PLSRegression(n_components=3)
pls1.fit(X, y)
```

### notebooks/dataset2/cross_decomposition/plot_pcr_vs_pls.ipynb
CONTEXT:  Projection on one component and predictive power  We now create two regressors: PCR and PLS, and for our illustration purposes we set the
number of components to 1. Before feeding the data to the PCA step of PCR, we first standardize it, as recommended by good practice. The PLS estimator
has built-in scaling capabilities.  For both models, we plot the projected data onto the first component against the target. In both cases, this
projected data is what the regressors will use as training data.   COMMENT:
```python
print(f"PCR r-squared {pcr.score(X_test, y_test):.3f}")
print(f"PLS r-squared {pls.score(X_test, y_test):.3f}")
```

## Code Concatenation
```python
n = 1000
p = 10
X = np.random.normal(size=n * p).reshape((n, p))
y = X[:, 0] + 2 * X[:, 1] + np.random.normal(size=n * 1) + 5
pls1 = PLSRegression(n_components=3)
pls1.fit(X, y)
print(f"PCR r-squared {pcr.score(X_test, y_test):.3f}")
print(f"PLS r-squared {pls.score(X_test, y_test):.3f}")
```
